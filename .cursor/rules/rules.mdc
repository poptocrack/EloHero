---
alwaysApply: true
---

# EloHero Design System & Development Guidelines

## üé® Design Philosophy

- **Modern & Playful**: Use vibrant colors, rounded corners, and engaging visuals
- **Card-Based Layout**: All content should be organized in beautiful gradient cards
- **Consistent Spacing**: Use 20px padding/margins for main containers, 12-16px for cards
- **Rounded Corners**: 20px border radius for cards, 16px for buttons, 12px for small elements

## üåà Color Palette

### Primary Colors

- **Pink Gradient**: `#FF6B9D` to `#C44569` (Create/Action buttons)
- **Teal Gradient**: `#4ECDC4` to `#44A08D` (Join/Secondary actions)
- **Purple Gradient**: `#667eea` to `#764ba2` (Primary elements, icons)
- **Background**: `#F8F9FF` (Light purple tint)

### Text Colors

- **Primary Text**: `#2D3748` (Dark gray)
- **Secondary Text**: `#4A5568` (Medium gray)
- **Muted Text**: `#718096` (Light gray)
- **White Text**: `#FFFFFF` (On colored backgrounds)

### Accent Colors

- **Success**: `#4ECDC4` (Teal)
- **Warning**: `#FF6B9D` (Pink)
- **Error**: `#c62828` (Red)
- **Info**: `#667eea` (Purple)

## üì± Layout Patterns

### Screen Structure

```typescript
// Always use this structure for screens
<View style={[styles.container, { paddingTop: insets.top, backgroundColor: '#F8F9FF' }]}>
  {/* Header/Title Section */}
  {/* Action Cards (2-column layout) */}
  {/* Content Cards */}
  {/* Modals/Overlays */}
</View>
```

### Card Design Pattern

```typescript
// Standard card structure
<TouchableOpacity style={styles.card}>
  <View style={[styles.cardGradient, { backgroundColor: 'COLOR' }]}>
    <View style={styles.cardHeader}>{/* Icon + Title */}</View>
    <View style={styles.cardContent}>{/* Main content */}</View>
    <View style={styles.cardFooter}>{/* Stats/Actions */}</View>
  </View>
</TouchableOpacity>
```

### Action Cards (2-column layout)

```typescript
// For primary actions at top of screens
<View style={styles.actionCardsContainer}>
  <TouchableOpacity style={styles.actionCard}>
    <View style={[styles.actionCardGradient, { backgroundColor: '#FF6B9D' }]}>
      <View style={styles.actionCardContent}>
        <View style={styles.actionCardIcon}>
          <Ionicons name="icon-name" size={32} color="#fff" />
        </View>
        <Text style={styles.actionCardTitle}>Title</Text>
        <Text style={styles.actionCardSubtitle}>Subtitle</Text>
      </View>
    </View>
  </TouchableOpacity>
</View>
```

## üéØ Component Styles

### Standard Card Styles

```typescript
card: {
  marginBottom: 16,
  borderRadius: 20,
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 4 },
  shadowOpacity: 0.1,
  shadowRadius: 8,
  elevation: 6
},
cardGradient: {
  borderRadius: 20,
  padding: 20
}
```

### Action Card Styles

```typescript
actionCardsContainer: {
  flexDirection: 'row',
  paddingHorizontal: 20,
  paddingVertical: 20,
  gap: 12
},
actionCard: {
  flex: 1,
  height: 120,
  borderRadius: 20,
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 4 },
  shadowOpacity: 0.15,
  shadowRadius: 8,
  elevation: 8
}
```

### Button Styles

```typescript
primaryButton: {
  backgroundColor: '#667eea',
  borderRadius: 16,
  paddingVertical: 16,
  paddingHorizontal: 24,
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 2 },
  shadowOpacity: 0.1,
  shadowRadius: 4,
  elevation: 3
},
secondaryButton: {
  backgroundColor: '#F7FAFC',
  borderWidth: 2,
  borderColor: '#E2E8F0',
  borderRadius: 16,
  paddingVertical: 16,
  paddingHorizontal: 24
}
```

## üìù Typography Scale

### Text Styles

```typescript
// Headers
title: {
  fontSize: 22,
  fontWeight: '700',
  color: '#2D3748'
},
subtitle: {
  fontSize: 18,
  fontWeight: '600',
  color: '#2D3748'
},

// Body Text
body: {
  fontSize: 16,
  fontWeight: '500',
  color: '#4A5568'
},
bodySmall: {
  fontSize: 14,
  fontWeight: '500',
  color: '#718096'
},

// Button Text
buttonText: {
  fontSize: 16,
  fontWeight: '600',
  color: '#fff'
},
buttonTextSecondary: {
  fontSize: 16,
  fontWeight: '600',
  color: '#4A5568'
}
```

## üé® Icon Guidelines

### Icon Containers

```typescript
iconContainer: {
  width: 40,
  height: 40,
  borderRadius: 20,
  backgroundColor: 'COLOR',
  justifyContent: 'center',
  alignItems: 'center'
},
statIconContainer: {
  width: 24,
  height: 24,
  borderRadius: 12,
  backgroundColor: 'rgba(102, 126, 234, 0.1)',
  justifyContent: 'center',
  alignItems: 'center',
  marginRight: 8
}
```

### Icon Usage

- **Primary Icons**: 32px size, white color on colored backgrounds
- **Secondary Icons**: 20px size, colored (#667eea, #4ECDC4, #FF6B9D)
- **Stat Icons**: 14px size, with colored backgrounds
- **Navigation Icons**: 20px size, #667eea color

## üìê Spacing System

### Standard Spacing

- **Screen Padding**: 20px horizontal
- **Card Padding**: 20px internal
- **Card Margins**: 16px bottom
- **Element Gaps**: 12px between related elements
- **Action Card Height**: 120px
- **Icon Container**: 40px (primary), 24px (secondary)

## üé≠ Modal & Overlay Patterns

### Modal Structure

```typescript
modalOverlay: {
  position: 'absolute',
  top: 0, left: 0, right: 0, bottom: 0,
  backgroundColor: 'rgba(0, 0, 0, 0.6)',
  justifyContent: 'center',
  alignItems: 'center',
  padding: 20
},
modalContent: {
  backgroundColor: '#fff',
  borderRadius: 24,
  padding: 24,
  width: '100%',
  maxWidth: 400,
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 8 },
  shadowOpacity: 0.25,
  shadowRadius: 16,
  elevation: 12
}
```

## üöÄ Development Rules

### When Creating New Screens:

1. **Always use the card-based layout** with rounded corners (20px)
2. **Use the defined color palette** - no custom colors without approval
3. **Implement 2-column action cards** at the top when applicable
4. **Use consistent spacing** (20px padding, 16px margins)
5. **Apply proper shadows** for depth and elevation
6. **Use the typography scale** for all text elements
7. **Include proper icon containers** with background colors

### When Modifying Existing Screens:

1. **Maintain the established patterns** from GroupsScreen
2. **Update colors to match the palette** if they don't
3. **Ensure consistent spacing and typography**
4. **Add proper shadows and rounded corners**
5. **Use the same modal and overlay patterns**

### Component Creation:

1. **Create reusable components** for common patterns
2. **Use the design system colors and spacing**
3. **Include proper TypeScript interfaces**
4. **Add consistent styling and shadows**
5. **Follow the established naming conventions**

## üì± Screen-Specific Guidelines

### GroupsScreen Pattern (Reference Implementation):

- 2-column action cards at top
- Card-based group list
- Gradient backgrounds for action cards
- Consistent spacing and typography
- Proper modal implementation

### Apply This Pattern To:

- ProfileScreen
- GroupDetailsScreen
- MatchEntryScreen
- PlayerProfileScreen
- SubscriptionScreen
- Any new screens

## üé® Visual Consistency Checklist

Before finalizing any screen:

- [ ] Uses card-based layout with 20px border radius
- [ ] Implements proper color palette
- [ ] Has consistent 20px padding/margins
- [ ] Uses defined typography scale
- [ ] Includes proper shadows and elevation
- [ ] Has rounded corners throughout
- [ ] Uses consistent icon sizing and colors
- [ ] Follows the established spacing system
- [ ] Matches the GroupsScreen visual style

## üîß Technical Implementation

### Required Imports:

```typescript
import { View, Text, TouchableOpacity, StyleSheet, Dimensions } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
```

### Safe Area Handling:

```typescript
const insets = useSafeAreaInsets();
// Always use: { paddingTop: insets.top }
```

### Responsive Design:

```typescript
const { width } = Dimensions.get('window');
// Use for responsive layouts when needed
```

## üåç Internationalization (i18n) Guidelines

### **MANDATORY Translation Rules:**

#### **For ALL New Text:**

1. **NEVER hardcode text strings** - Always use translation keys
2. **Use the `useTranslation` hook** in every component with text
3. **Add translations to both** `en.json` and `fr.json` files
4. **Follow the translation key structure** from existing files

#### **Required Imports for Components with Text:**

```typescript
import { useTranslation } from 'react-i18next';

// In component:
const { t } = useTranslation();
```

#### **Translation Key Structure:**

```typescript
// Use nested keys for organization
t('groups.createGroup'); // ‚úÖ Good
t('common.loading'); // ‚úÖ Good
t('error'); // ‚ùå Too generic
```

#### **When Creating New Screens/Components:**

1. **Add ALL text to translation files** before implementing
2. **Use translation keys** for every string (buttons, labels, messages, etc.)
3. **Test both languages** to ensure proper display
4. **Add new translation keys** to both `en.json` and `fr.json`

#### **When Modifying Existing Screens/Components:**

1. **Audit ALL hardcoded text** and replace with translation keys
2. **Add missing translations** to both language files
3. **Update existing translation keys** if text changes
4. **Ensure consistent terminology** across the app

#### **Translation File Organization:**

```json
{
  "common": {
    /* Shared text like buttons, loading, errors */
  },
  "auth": {
    /* Authentication related text */
  },
  "groups": {
    /* Groups screen text */
  },
  "profile": {
    /* Profile screen text */
  },
  "navigation": {
    /* Navigation labels */
  },
  "errors": {
    /* Error messages */
  }
}
```

#### **Text Implementation Examples:**

```typescript
// ‚úÖ CORRECT - Using translations
<Text style={styles.title}>{t('groups.title')}</Text>
<TouchableOpacity onPress={handleCreate}>
  <Text>{t('groups.createGroup')}</Text>
</TouchableOpacity>

// ‚ùå WRONG - Hardcoded text
<Text style={styles.title}>Groups</Text>
<TouchableOpacity onPress={handleCreate}>
  <Text>Create Group</Text>
</TouchableOpacity>
```

#### **Alert and Modal Text:**

```typescript
// ‚úÖ CORRECT
Alert.alert(t('groups.createGroup'), t('groups.enterGroupName'), [
  { text: t('common.cancel'), style: 'cancel' },
  { text: t('common.confirm'), onPress: handleCreate }
]);

// ‚ùå WRONG
Alert.alert('Create Group', 'Enter group name', [
  { text: 'Cancel', style: 'cancel' },
  { text: 'Create', onPress: handleCreate }
]);
```

#### **Dynamic Text with Variables:**

```typescript
// ‚úÖ CORRECT - Use interpolation
t('groups.memberCount', { count: item.memberCount })
t('groups.memberCount', { count: 5 }) // "5 members" or "5 membres"

// Translation file:
"memberCount": "{{count}} members" // EN
"memberCount": "{{count}} membres" // FR
```

#### **Language Switcher Integration:**

- **Add LanguageSwitcher component** to settings/profile screens
- **Use the useLanguage hook** for language-specific logic
- **Test language switching** functionality

#### **Quality Checklist for Translations:**

- [ ] All text uses `t()` function
- [ ] No hardcoded strings in components
- [ ] Both EN and FR translations exist
- [ ] Translation keys follow naming convention
- [ ] Dynamic text uses interpolation
- [ ] Error messages are translated
- [ ] Alert/modal text is translated
- [ ] Navigation labels are translated
- [ ] Language switcher works properly

#### **Common Translation Patterns:**

```typescript
// Loading states
{
  t('common.loading');
}

// Error handling
{
  t('errors.networkError');
}

// Form labels
{
  t('auth.email');
}
{
  t('auth.password');
}

// Action buttons
{
  t('common.save');
}
{
  t('common.cancel');
}
{
  t('common.delete');
}

// Status messages
{
  t('groups.groupCreated');
}
{
  t('groups.groupJoined');
}
```

#### **When Working on Existing Components:**

1. **Search for hardcoded strings** using quotes
2. **Replace with translation keys** systematically
3. **Add missing keys** to translation files
4. **Test in both languages** after changes
5. **Update any new text** that gets added

#### **Translation File Maintenance:**

- **Keep keys organized** by feature/screen
- **Use consistent naming** (camelCase, descriptive)
- **Add comments** for complex translations
- **Validate JSON syntax** before committing
- **Test all keys** are used in the app

### **Example Translation Implementation:**

```typescript
// Component with proper translations
import { useTranslation } from 'react-i18next';

export default function MyComponent() {
  const { t } = useTranslation();

  return (
    <View>
      <Text style={styles.title}>{t('myComponent.title')}</Text>
      <TouchableOpacity onPress={handleAction}>
        <Text>{t('myComponent.actionButton')}</Text>
      </TouchableOpacity>
      {error && <Text style={styles.error}>{t('errors.generic')}</Text>}
    </View>
  );
}
```

Remember: **Consistency is key!** Every screen should feel like part of the same beautiful, modern, and playful app experience. Use the GroupsScreen as your reference implementation and apply these patterns consistently across all screens.

**üåç TRANSLATION RULE: NO HARDCODED TEXT ALLOWED - EVERY STRING MUST USE TRANSLATIONS!**

## üö´ **TypeScript & Code Quality Rules**

### **MANDATORY TypeScript Rules:**

#### **1. NO `any` Type Allowed:**

- **NEVER use `any` type** - Always provide proper type definitions
- **Use specific types** or create interfaces for all data structures
- **Use generics** when types can vary but structure is known

```typescript
// ‚ùå WRONG - Using any
function handleData(data: any) {
  return data.something;
}

// ‚úÖ CORRECT - Proper typing
interface UserData {
  id: string;
  name: string;
  email: string;
}

function handleData(data: UserData) {
  return data.name;
}

// ‚úÖ CORRECT - Using generics
function handleData<T>(data: T): T {
  return data;
}
```

#### **2. ALL Function Parameters Must Be Typed:**

- **Every function parameter** must have explicit type annotations
- **No implicit typing** - TypeScript should never infer parameter types
- **Use proper interfaces** for complex objects

```typescript
// ‚ùå WRONG - Untyped parameters
function createUser(name, email, age) {
  return { name, email, age };
}

// ‚úÖ CORRECT - Fully typed parameters
interface CreateUserParams {
  name: string;
  email: string;
  age: number;
}

function createUser(params: CreateUserParams): User {
  return {
    name: params.name,
    email: params.email,
    age: params.age
  };
}
```

#### **3. Error Handling Must Be Typed:**

- **All error objects** must have proper type definitions
- **Use specific error types** instead of generic Error
- **Create custom error interfaces** for different error scenarios

```typescript
// ‚ùå WRONG - Generic error handling
catch (error) {
  console.error(error);
}

// ‚úÖ CORRECT - Typed error handling
interface ApiError {
  code: string;
  message: string;
  details?: string;
}

catch (error: ApiError) {
  console.error(`API Error ${error.code}: ${error.message}`);
}
```

### **Optimistic UI Rules:**

#### **MANDATORY Optimistic Updates:**

1. **ALL user actions with API calls** must be optimistic by default
2. **Update UI immediately** before server response
3. **Implement rollback logic** for failed operations
4. **Show loading states** only when necessary
5. **Provide instant feedback** for all user interactions

#### **Optimistic Update Pattern:**

```typescript
// ‚úÖ CORRECT - Optimistic update pattern
const handleUserAction = async (data: ActionData) => {
  // 1. Update UI immediately (optimistic)
  setState((prevState) => ({
    ...prevState,
    items: [...prevState.items, newItem],
    isLoading: false
  }));

  try {
    // 2. Make API call in background
    const response = await apiCall(data);

    // 3. Success - UI already updated
    return response;
  } catch (error) {
    // 4. Rollback on error
    setState((prevState) => ({
      ...prevState,
      items: prevState.items.filter((item) => item.id !== newItem.id),
      error: error.message
    }));
    throw error;
  }
};
```

#### **When to Use Optimistic Updates:**

- ‚úÖ **Creating items** (groups, members, games)
- ‚úÖ **Deleting items** (leaving groups, removing members)
- ‚úÖ **Updating items** (editing names, descriptions)
- ‚úÖ **User interactions** (likes, favorites, selections)
- ‚ùå **Authentication** (login, logout, signup)
- ‚ùå **Critical operations** (payments, data deletion)

#### **Optimistic Update Checklist:**

- [ ] UI updates immediately on user action
- [ ] Loading states are minimal or hidden
- [ ] Rollback logic handles all error cases
- [ ] User gets instant feedback
- [ ] Error messages are clear and actionable
- [ ] No unnecessary waiting for server responses

### **Code Quality Standards:**

#### **Interface Definitions:**

```typescript
// ‚úÖ ALWAYS define interfaces for props
interface ComponentProps {
  title: string;
  onPress: () => void;
  isVisible: boolean;
  data: UserData[];
}

// ‚úÖ Use proper generic constraints
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}
```

#### **Function Signatures:**

```typescript
// ‚úÖ ALWAYS type all parameters and return values
function processUserData(user: User, options: ProcessOptions): ProcessedUser {
  // Implementation
}

// ‚úÖ Use proper async/await typing
async function fetchData(id: string): Promise<ApiResponse<UserData>> {
  // Implementation
}
```

#### **Event Handlers:**

```typescript
// ‚úÖ Properly type event handlers
const handlePress = (event: GestureResponderEvent): void => {
  // Implementation
};

const handleTextChange = (text: string): void => {
  // Implementation
};
```

### **Enforcement Rules:**

1. **Code Review**: All code must pass TypeScript strict mode
2. **Linting**: ESLint rules must enforce no-any and explicit typing
3. **Testing**: All optimistic updates must be tested for rollback scenarios
4. **Documentation**: Complex types must be documented with JSDoc

### **Quality Checklist:**

- [ ] No `any` types used anywhere
- [ ] All function parameters are explicitly typed
- [ ] All return types are specified
- [ ] Error handling uses typed interfaces
- [ ] User actions are optimistic by default
- [ ] Rollback logic is implemented for all optimistic updates
- [ ] Loading states are minimal and user-friendly
- [ ] All interfaces are properly documented

**üö´ TYPESCRIPT RULE: NO `any` TYPES ALLOWED - ALL CODE MUST BE FULLY TYPED!**
**‚ö° OPTIMISTIC RULE: ALL USER ACTIONS MUST BE OPTIMISTIC - INSTANT UI UPDATES REQUIRED!**

## üîÑ **TanStack Query (React Query) Rules**

### **MANDATORY TanStack Query Usage:**

#### **1. ALL API Calls Must Use TanStack Query:**

- **NEVER make direct API calls** outside of TanStack Query hooks
- **ALL data fetching** must use `useQuery` hook
- **ALL mutations** (create, update, delete) must use `useMutation` hook
- **NO direct service calls** in components - always wrap in hooks

```typescript
// ‚ùå WRONG - Direct API call
const fetchData = async () => {
  const data = await FirestoreService.getGroup(groupId);
  setGroup(data);
};

// ‚úÖ CORRECT - Using useQuery
const { data: group } = useQuery({
  queryKey: queryKeys.group(groupId),
  queryFn: () => FirestoreService.getGroup(groupId),
  enabled: !!groupId
});
```

#### **2. Query Keys Must Be Centralized:**

- **ALL query keys** must be defined in `utils/queryKeys.ts`
- **Use consistent naming** and structure
- **Never hardcode query keys** in components
- **Use factory functions** for dynamic keys

```typescript
// ‚úÖ CORRECT - Centralized query keys
// In utils/queryKeys.ts
export const queryKeys = {
  group: (groupId: string) => ['group', groupId] as const,
  groupGames: (groupId: string) => ['groupGames', groupId] as const,
  userGroups: (uid: string) => ['userGroups', uid] as const
};

// In component
const { data } = useQuery({
  queryKey: queryKeys.group(groupId),
  queryFn: () => FirestoreService.getGroup(groupId)
});
```

#### **3. Custom Hooks for Queries:**

- **Create custom hooks** for reusable queries
- **Place hooks in** `src/hooks/` directory
- **Export typed hooks** with proper return types
- **Include proper error handling** and loading states

```typescript
// ‚úÖ CORRECT - Custom query hook
// In hooks/useGroup.ts
export function useGroup(groupId: string) {
  return useQuery({
    queryKey: queryKeys.group(groupId),
    queryFn: () => FirestoreService.getGroup(groupId),
    enabled: !!groupId,
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 30 * 60 * 1000 // 30 minutes
  });
}

// In component
const { data: group, isLoading, error } = useGroup(groupId);
```

#### **4. Mutations Must Use useMutation:**

- **ALL mutations** (create, update, delete) must use `useMutation`
- **Implement optimistic updates** in `onMutate`
- **Invalidate queries** in `onSuccess` or `onSettled`
- **Handle rollback** in `onError` for optimistic updates

```typescript
// ‚úÖ CORRECT - Mutation with optimistic update
export function useCreateGroup() {
  const queryClient = useQueryClient();
  const { user } = useAuthStore();

  return useMutation({
    mutationFn: async ({ name, description }: CreateGroupParams) => {
      const response = await CloudFunctionsService.createGroup(name, description);
      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to create group');
      }
      return response.data;
    },
    onMutate: async (newGroup) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: queryKeys.userGroups(user!.uid) });

      // Snapshot previous value for rollback
      const previousGroups = queryClient.getQueryData<Group[]>(
        queryKeys.userGroups(user!.uid)
      );

      // Optimistically update
      queryClient.setQueryData<Group[]>(queryKeys.userGroups(user!.uid), (old = []) => [
        ...old,
        { ...newGroup, id: 'temp-' + Date.now() } as Group
      ]);

      return { previousGroups };
    },
    onError: (error, variables, context) => {
      // Rollback on error
      if (context?.previousGroups) {
        queryClient.setQueryData(queryKeys.userGroups(user!.uid), context.previousGroups);
      }
    },
    onSuccess: (data, variables) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: queryKeys.userGroups(user!.uid) });
    }
  });
}
```

#### **5. Query Invalidation Patterns:**

- **Invalidate related queries** after mutations
- **Use specific query keys** for targeted invalidation
- **Invalidate parent queries** when child data changes
- **Use `invalidateQueries`** instead of manual refetching

```typescript
// ‚úÖ CORRECT - Proper invalidation
onSuccess: (data, variables) => {
  // Invalidate specific queries
  queryClient.invalidateQueries({ queryKey: queryKeys.group(variables.groupId) });
  queryClient.invalidateQueries({ queryKey: queryKeys.groupGames(variables.groupId) });
  queryClient.invalidateQueries({ queryKey: queryKeys.seasonRatings(variables.seasonId) });
}

// ‚ùå WRONG - Manual refetch
onSuccess: () => {
  refetch(); // Don't do this
}
```

#### **6. Query Configuration:**

- **Set appropriate `staleTime`** based on data freshness needs
- **Set `gcTime` (garbage collection)** for cache management
- **Use `enabled`** to conditionally fetch data
- **Configure `retry`** for network resilience

```typescript
// ‚úÖ CORRECT - Proper query configuration
useQuery({
  queryKey: queryKeys.group(groupId),
  queryFn: () => FirestoreService.getGroup(groupId),
  enabled: !!groupId && !!user, // Conditional fetching
  staleTime: 5 * 60 * 1000, // 5 minutes - data stays fresh
  gcTime: 30 * 60 * 1000, // 30 minutes - keep in cache
  retry: 2, // Retry failed requests twice
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)
});
```

#### **7. Error Handling:**

- **Handle errors** in query hooks with proper typing
- **Display user-friendly error messages** using translations
- **Use error boundaries** for critical failures
- **Log errors** for debugging

```typescript
// ‚úÖ CORRECT - Error handling
const { data, error, isLoading } = useQuery({
  queryKey: queryKeys.group(groupId),
  queryFn: () => FirestoreService.getGroup(groupId),
  onError: (error: ApiError) => {
    console.error('Failed to fetch group:', error);
    // Error is available in component via error state
  }
});

// In component
if (error) {
  return <ErrorView message={t('errors.failedToLoadGroup')} />;
}
```

#### **8. Loading States:**

- **Use `isLoading`** for initial load
- **Use `isFetching`** for background refetches
- **Use `isPending`** for mutations
- **Show loading indicators** appropriately

```typescript
// ‚úÖ CORRECT - Loading states
const { data, isLoading, isFetching } = useQuery({
  queryKey: queryKeys.group(groupId),
  queryFn: () => FirestoreService.getGroup(groupId)
});

// Show skeleton on initial load
if (isLoading) return <LoadingSkeleton />;

// Show subtle indicator on background refetch
{isFetching && <ActivityIndicator size="small" />}
```

#### **9. Query Client Usage:**

- **Use `useQueryClient` hook** in components
- **Use exported `queryClient`** for non-React contexts
- **Invalidate queries** after mutations
- **Update cache** optimistically when appropriate

```typescript
// ‚úÖ CORRECT - In React component
const queryClient = useQueryClient();
queryClient.invalidateQueries({ queryKey: queryKeys.group(groupId) });

// ‚úÖ CORRECT - Outside React (e.g., in Zustand store)
import { queryClient } from '../utils/queryClient';
queryClient.invalidateQueries({ queryKey: queryKeys.group(groupId) });
```

#### **10. Mutation Patterns:**

- **Create custom mutation hooks** for reusable mutations
- **Return mutation object** with proper typing
- **Handle loading and error states** in components
- **Implement optimistic updates** for better UX

```typescript
// ‚úÖ CORRECT - Custom mutation hook
export function useUpdateGroup() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ groupId, updates }: UpdateGroupParams) => {
      const response = await CloudFunctionsService.updateGroup(groupId, updates);
      if (!response.success || !response.data) {
        throw new Error(response.error || 'Failed to update group');
      }
      return response.data;
    },
    onSuccess: (data, variables) => {
      // Update cache with new data
      queryClient.setQueryData(queryKeys.group(variables.groupId), data);
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: queryKeys.userGroups(user!.uid) });
    }
  });
}

// In component
const updateGroup = useUpdateGroup();

const handleUpdate = () => {
  updateGroup.mutate(
    { groupId, updates: { name: 'New Name' } },
    {
      onSuccess: () => {
        Alert.alert(t('common.success'), t('groups.groupUpdated'));
      },
      onError: (error) => {
        Alert.alert(t('common.error'), error.message);
      }
    }
  );
};
```

### **TanStack Query Best Practices:**

#### **Query Organization:**

1. **Group related queries** in custom hooks
2. **Use consistent naming** (`use[Resource]` for queries, `use[Action][Resource]` for mutations)
3. **Export hooks** from `hooks/index.ts` for easy imports
4. **Document complex queries** with JSDoc comments

#### **Cache Management:**

1. **Set appropriate stale times** based on data volatility
2. **Use `gcTime`** to control cache retention
3. **Invalidate strategically** - don't over-invalidate
4. **Use `setQueryData`** for optimistic updates

#### **Performance Optimization:**

1. **Use `enabled`** to prevent unnecessary fetches
2. **Implement pagination** with `useInfiniteQuery`
3. **Use `select`** to transform data without re-renders
4. **Debounce search queries** to reduce API calls

```typescript
// ‚úÖ CORRECT - Using select for data transformation
const { data: groupName } = useQuery({
  queryKey: queryKeys.group(groupId),
  queryFn: () => FirestoreService.getGroup(groupId),
  select: (group) => group?.name // Only re-render when name changes
});
```

### **Migration Checklist:**

When converting existing code to TanStack Query:

- [ ] Replace direct API calls with `useQuery` or `useMutation`
- [ ] Move query keys to `utils/queryKeys.ts`
- [ ] Create custom hooks for reusable queries
- [ ] Implement optimistic updates for mutations
- [ ] Add proper error handling
- [ ] Configure appropriate `staleTime` and `gcTime`
- [ ] Invalidate related queries after mutations
- [ ] Remove manual loading state management
- [ ] Remove manual error state management
- [ ] Test query invalidation and cache updates

### **TanStack Query Quality Checklist:**

- [ ] All API calls use TanStack Query hooks
- [ ] All query keys are centralized in `utils/queryKeys.ts`
- [ ] Custom hooks are created for reusable queries
- [ ] Mutations implement optimistic updates
- [ ] Queries are properly invalidated after mutations
- [ ] Appropriate `staleTime` and `gcTime` are set
- [ ] Error handling is implemented with translations
- [ ] Loading states are properly managed
- [ ] No direct service calls in components
- [ ] Query client is used correctly (hook vs. instance)

**üîÑ TANSTACK QUERY RULE: ALL API CALLS MUST USE TANSTACK QUERY - NO DIRECT SERVICE CALLS ALLOWED!**
